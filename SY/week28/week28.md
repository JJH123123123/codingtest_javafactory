## BackJoon : week28th Problems of class 5 in Backjoon

| 인덱스 | 문제 번호 | 문제 제목 | 자료구조/알고리즘 | URL |
|--------|------------|-----------------------------|------------------|------------------------------------------------|
| 556    | 2467       | 용액               |                  | [2467](https://www.acmicpc.net/problem/2467)   |
| 557    | 15681       | 트리와 쿼리               |                  | [15681](https://www.acmicpc.net/problem/15681)   |
| 558    | 1647       | 도시 분할 계획               |                  | [1647](https://www.acmicpc.net/problem/1647)   |
| 559    | 1806       | 부분합               |                  | [1806](https://www.acmicpc.net/problem/1806)   |
| 560    | 9252       | LCS 2               |                  | [9252](https://www.acmicpc.net/problem/9252)   |
| 561    | 10942       | 팰린드롬?               |                  | [10942](https://www.acmicpc.net/problem/10942)   |
| 562    | 1005       | ACM Craft               |                  | [1005](https://www.acmicpc.net/problem/1005)   |
| 563    | 1644       | 소수의 연속합               |                  | [1644](https://www.acmicpc.net/problem/1644)   |
| 564    | 2143       | 두 배열의 합               |                  | [2143](https://www.acmicpc.net/problem/2143)   |
| 565    | 2252       | 줄 세우기               |                  | [2252](https://www.acmicpc.net/problem/2252)   |

---

## 문제 해설

- **Problem 556:** 용액  ,투포인터, 이분탐색
- 풀이 및 해설 :  주어진 값들이 오름차순으로 정렬되있기때문에 투포인터 혹은 이분탐색을 이용하여 값 하나를 기준으로 나머지 값중 선택할수있는 합의 절댓값이 0에 가까운 값으로 계속 갱신한다
- 시간 복잡도 :  O(N * logN) 이분탐색 O(N) 투포인터
<br><br><br>

- **Problem 557:** 트리와 쿼리  ,그래프탐색, DP
- 풀이 및 해설 :  트리문제, 서브트리에대한 연산결과를 미리 기록하여 추가적인 dfs탐색을 하지않게끔 하여 쿼리처리에대한 시간을 줄인다
cnt에대한 연산결과를 dfs의 탐색결과로 리턴하므로 추가로 갯수를 세는 연산시간을 줄여 쿼리의 처리를 O(1)만에 해결한다
- 시간 복잡도 :  O(V + E)
<br><br><br>

- **Problem 558:** 도시 분할 계획  ,UnionFind, MST
- 풀이 및 해설 :  MST문제, 문제에서 주어진 요구사항은 주어진 간선정보를 기반으로 MST를 구성하고 이중 가장 큰 가중치의 간선을 끊어낸다, 이로인해
모든 마을을 연결시킨후 가장 큰간선을 끊어내는 것으로 모두연결되어있으면서 두마을의 가중치가 최소인 결과가 나온다
- 시간 복잡도 :  O(N*logN + N(아커만함수,DS))
<br><br><br>

- **Problem 559:** 부분합  ,투포인터, 이분탐색
- 풀이 및 해설 :  투포인터를 이용하여 누적된 계산합을 통해 비교하던가 혹은 이분탐색을 이용하여 원하는 길이대로 스플릿하여 이에맞는 조건이 누적합의 부분합들중 있는가 체크한다
- 시간 복잡도 :  투포인터O(N), 이분탐색(N + (logN ~ N,유망함수내에서의 순회))
<br><br><br>

- **Problem 560:** LCS 2  ,DP
- 풀이 및 해설 :  두 문자열을 기준으로 최장공통수열LCS를 찾고 이에대한 길이와 LCS를 출력하는문제 이를위해 n^2 즉 dp를 이용해 구현한다
점화식 dp를 dp[문자열1의 0~i까지의인덱스][문자열2의 0~j까지의인덱스] = 문자열1~i와 문자열2~j까지의 최장공통부분수열길이 로 잡는다,
이때 특정 최장길이는 결국 이전의 최장길이에서
영향을 받으므로 양 끝단, 즉 공통수열이 새롭게 추가되는부분이 같지 않으면 이전길이중 최대값을 가져오고
같다면 새로 추가된 문자열의 양끝단이 하나씩 추가된 형태이므로 dp[i-1][j-1]에서 길이를 +1 해준다,
이후 최장끝단을 기준으로 길이값을 위의 추가방식대로 dir을 역추적해 출력한다
- 시간 복잡도 :  O(N^2)
<br><br><br>

- **Problem 561:** 팰린드롬?  ,DP
- 풀이 및 해설 :  DP[i][j] = 원소 i~j까지의 최장팰린드롬길이 로 잡고 점화식을 구성, 양쪽끝이 같다면 +2로 양쪽을 하나씩늘려주는형태, 아니면 왼쪽,오른쪽중 긴녀석으로택하여 DP를갱신
- 시간 복잡도 :  O(N^2)
<br><br><br>

- **Problem 562:** ACM Craft  ,위상정렬, DP
- 풀이 및 해설 :  위상정렬문제, 주어진 건물짓는시간을 점화식dp의 초기값으로 둔다, 점화식dp는
dp[node] = node를 짓는데 걸리는 소요시간 으로 둘때 최소 dp값은 자신의건물을 짓는시간만큼은 무조건 걸리기때문에 입력값 D와 동일한 값으로 초기화한다, 이후 위상정렬을 이용해 진입차수를 0인 순서대로 queue에서 pop하여 건물을 지어나간다, 현재 시작위치인 cur에서 다음 건물의 짓는시간과 비교하여 기존에 건물을 짓는시간보다 dp[cur] + dp[iter] 즉, 현재의 시간+다음건물 짓는시간이 더 오래걸린다면 갱신해준다
- 시간 복잡도 :  O(T * (N + K))
<br><br><br>

- **Problem 563:** 소수의 연속합  ,투포인터, 정수론(에라토스테네스의체,소수판별)
- 풀이 및 해설 :  연속된 소수의 합이 입력된값 N을 만들수 있는가를 묻는문제, 즉 소수로 나열된 수열이 있을때 이에대한 연속된 부분합을 찾는문제로
귀결된다, 이를위해서 소수를 최대값N인 4'000'000까지의  기준으로 에라토스테네스의 체를 이용해 소수배열을 만들고
이를 투포인터를 이용하여 슬라이딩윈도우 방식으로 찾아가며 경우의수를 센다
- 시간 복잡도 :  O(NloglogN + primessize())
<br><br><br>

- **Problem 564:** 두 배열의 합  ,경우의수, 누적합, 이분탐색
- 풀이 및 해설 :  두 배열의 길이에따른 누적합 배열 psumsA, psumsB를 만들고 이를 정렬한다, 이후 두 배열을 기반으로하여 두 합이 T일때 이에대한 갯수를 카운팅해 경우의수의 연속사건상 곱하여 더한다
이때 같은값을 찾는방식을 투포인터에 이분탐색을 같이 적용시켜 한쪽은 오름차순으로정렬된값에서 같은갯수를찾고 한쪽은 내림차순에서 정렬된값에서 같은갯수를찾아 upperbound, lowerbound를 각각 찾아내서갯수를센다
- 시간 복잡도 : O(N^2 + M^2 + ((N+M) * (logN+logM))), A컨테이너복잡도+B컨테이너복잡도+(N+M투포인터)*(upperbound+lowerbound)   
<br><br><br>

- **Problem 565:** 줄 세우기  ,위상정렬
- 풀이 및 해설 :  그래프의 입력이 주어지고 앞에 선행된 방향순서대로 출력값이 나와야하므로 위상정렬을 이용해 순서를 찾는다
A,B에서 B에 해당하는 indegree의 값을 늘려주어 indegree가 0인 진입차수0짜리를 queue넣고 순서대로 그래프를 탐색한다
- 시간 복잡도 :  O(N+M)
<br><br><br>
