# Java_codingTest_2ndWeek

## 문제 해설

- 문제 이해 → 풀이 방향 : 구현, 연산 3개를 구현하는 부분이 까다로울 수도 있을 거 같다.
- 사용한 자료구조 & 시간복잡도 : O(100 * MAX(10초전 이동, 10초후 이동,오프닝 건너뛰기))
- (option 참고 문제 & 참고 링크 등등) :  유사한? 문제 백준 :  https://www.acmicpc.net/problem/1942

problem 21 :   기사단원의 무기 

- 문자 해설 : 기사단원의 번호가 배정이 된다. 그 배정된 번호의 약수의 개수만큼 철을 구해야 하나 limit를 넘어갈 경우 무기의 공격력을 power로 대체한다. 무기 공격력 1당 1kg의 철이 필요하다. 필요한 철은?
- result += (factorNumber(i) > limit) ? power : factorNumber(i); 를 해주고 리턴한다.
- 시간복잡도 : O(N + Nlog(log(N)))
- 알고리즘 : 수학

problem 22 : 과일장수

- 문제 해설 : 과일장수는 상자를 잘 포장해서 최대이익을 얻고 싶다. 상자를 포장하여 점수를 얻는 방식은 상자에 들어간 최저값 * 상자에 들어간 과일의 개수이다. 그러므로 score을 전부 heapify 했을 때 score.length % m 만큼은 상자를 구성할 수 없기 때문에 pop을 해준다. 그 뒤에
- 왜 max_heap이 아니라 min_heap으로 pq를 정의하는 걸까? ⇒ max_heap으로 한다면
- 사용한 및 자료구조 & 알고리즘 : heap, priorityqueue
- 시간복잡도 : ( nlogn + nlog(n)) ⇒ heapify + for-loop with delete min

problem 23 : 푸트파이트 대회

- 문제 해설 : 처음에 과일 개수에 대한 배열인 food가 주어집니다. 0번 과일부터 시작하는데 여기서 0번은 물로, 두 선수 모두 다 마지막엔 물을 마셔야 합니다. 한 선수는 왼쪽에서 오른쪽으로 과일을 먹고, 다른 한 선수는 반대로 과일을 먹는데 칼로리 순(=과일 순서순)으로 과일을 먹습니다. 둘다 마지막엔 물을 마셔야 되기 때문에 0을 먼저 넣어줍니다. 그 뒤엔 food.length-1부터 접근해서 cnt = food[i]/2 만큼, deq의 앞, 뒤로 i값을 넣어줍니다. 그렇고 넣은 deq를 StringBuilder로 바꿔서 return 값을 만들고 반환합니다.
- 사용한 자료구조 : Dequeue
- 시간복잡도 : O(N)

problem 24 : 햄버거 만들기 

- 문제 해설 : 햄버거를 만드는 과정은 빵 야채 고기 빵 순으로 이뤄져야 햄버거가 됩니다. 여기서 빵, 야채, 고기는 ingredient에서 1 ,2, 3 값으로 대체돼서 표현되어있습니다. 총 몇개 햄버거를 만들 수 있는지? 자바의 ArrayList를 이용해서 풀었습니다. 현재 스택의 길이가 4보다 길거나 같고, 제일 뒤에 있는 값이 빵이고, 그리고 그 인덱스를 기준으로 그 뒤, 그 뒤에 뒤, 이렇게 4개 원소를 확인했습니다. 맞는 경우는 빵을 만들 수 있는 경우이므로 뒤에 값 4개를 제거하고, hamburger의 count를 증가시켜줬습니다.
- 사용한 알고리즘 및 자료구조 : ArrayList
- 시간복잡도 : O(N)

problem 25 : 옹알이 (2)  

- 문제 해설 : "aya", "ye", "woo", "ma"와 이 단어를 조합해서 만든 단어를 말할 수 있다. 단, 똑같은 단어를 연속해서 말하는 건 불가능하다. 예를 들면 mama 는 불가능하다. isValidBabble 메소드를 만들어서 옹알이가 가능한지, 체크해려고 했다. isValidBabble의 논리는 간단하다. 현재 위치에서(idx)에서 hashSet에 저장된 단어 4개로 시작되는 것이 있는지 체크한다. prev를 이용해서 이전에 사용했던 String을 저장해둬서 중복을 체크한다. 문자를 찾을 수 없으면 found = false를 바꾸고 탈출한다. 중복이 생기거나 현재 인덱스에서 어떤 것도 찾을 수 없으면 false로 반환한다. 그런 경우가 존재하지 않으면 return true한다.
- 사용한 자료구조 : HashSet
- 시간복잡도 : O(babbling 배열에 들어가는 String의 길이의 합)

problem 26 : 콜라 문제 

- 문제 해설 : 빈 콜라병의 개수가 n개 주어지고, a개를 마트에 가져다주면 b개의 콜라를 새로 받습니다. 현재 주어진 콜라병에서 다음 단계로 넝어갈 때는 remain = n%a; n = b*(n/a) + remain로 저장해줍니다. n이 a 이상일 때까지 계속 반복합니다. 마트에서 주는 콜라(=b*(n/a))를 전부 모아서 return 해줍니다.
- 시간복잡도 : O( $\log_a(n))$

probelm 27 : 삼총사 

- 문제해설 : 서로 다른 인덱스에 위치한 세 값을 선택해서 0이 되는 값을 찾고 cnt++를 해줍니다.
- 시간복잡도 : O(13 * 12 * 11)
- 사용한 자료구조 & 알고리즘 : 구현

problem 28 : 숫자짝꿍

- 문제해설 : 주어진 X와 Y값을 미리 선언해둔 HashMap을 이용해서 각 숫자를 카운트 해줍니다. 그 다음에 String ret = “”에 XX와 YY 둘중에서 작은 값만큼 현재 숫자를 문자열로 바꿔서 갱신해줍니다. 그 결과 나온 ret 값이 “”라면 -1를 리턴해줍니다.
- 시간복잡도 : O(|X| + |Y|)
- 사용한 자료구조 & 알고리즘 : Counting Sort & HashMap

problem 29 :  성격유형검사하기 

- 문제해설 : 성격 유형은 “RT”, “CF”, “JM”, “AN”  이렇게 4개로 나뉜다. survey에 들어가는 스트링에 따라 점수를 준다. 질문은 오른쪽 질문에 대해서 동의를 하는가 하지 않는가다. 그래서 비동의를 하면(비동의 choice값 1에서 3) 왼쪽값에 대한 기록을 해야 하고, 동의를 하면 오른쪽값에 대해서 기록을 해야 한다.
- 시간복잡도 O(1)

problem 30 : 신고결과 받기 

- 문제 해설 : 인접행렬을 이용해서 directed graph처럼 누가, 누구를 신고했는지 기록한다. 이 전처리를 끝내고, 각 사람마다 경우의 수를 기록해서 제출한다.
- 시간복잡도 : O($n^2$)
- 사용한 자료구조 : 인접행렬

problem 31 : **나머지가 1이 되는 수 찾기**

- 문제 해설 : 주어진 n보다 작은 수로 n을 나눴을 때 나머지가 1이 되는 경우를 찾는데 그 중 가장 작은 수를 리턴하려고 한다.
- 시간복잡도 : O(n)
- 알고리즘 : 구현

problem 32 : 최소 직사각형 

- 문제 해설 : for문을 돌면서 sizes의 원소 각각을 정렬한다. tmp에 현재 sizes의 원소값을 할당하고, 각각의 원소 최댓값을 갱신해준다. 그리고 두 길의의 곱을 계산하여 리턴한다.
- 시간복잡도 : O($N$)

problem 33 : 없는 숫자 더하기 

- 문제 해설 : 0부터 9까지 합을 구하고, 0부터 9까지 포문을 돌면서 numbers에 있는 값을 뺀다.
- 시간복잡도 : O(9)

problem 34 :  **부족한 금액 계산하기**

- 문제 해설 : 현재 가지고 있는 값을 money, 한번 타는데 추가되는 비용을 money, 놀이기구를 타는 경우를 count로 정의한다. 놀이기구를 한번 더 타면 money만큼 비용이 더 추가돼서 내야 한다. 즉 내야하는 총금액은 (count+1)(count)/2 가 나온다.
- 시간복잡도 : O(N)

problem 35 : **숫자 문자열과 영단어**

- 문제 해설 : HashMap에 “one”, “two”, “three” 등의 숫자를 int 자료형으로 기록을 해준다. 그 다음에 주어진 문자열을 읽으면서 char 값이 48 ≤ char ≤ 57 이면 더해준다. 0으로 시작하는 경우는 없다고 했기 때문에 그것에 대한 고려는 안해줘도 된다. char 값이 숫자형이 아니라면, tmp_str을 계속 더해준다. 그러다가 저장된 HashMap에 저장된 값이라면 ret값에 숫자로 바꿔서 더해주고, tmp_str= “”로 바꿔준다.
- 사용한 자료형 : HashMap
- 시간 복잡도 : $O(\text{|N|})$

problem 36 : 약수의 개수와 덧셈 

- 문제 해설 : 주어진 숫자에 대해서 ceil과 sqrt를 이용해서 isPrime를 판단하는 알고리즘을 이용해서 약수의 개수가 짝수인지 홀수인지 판단하는 알고리즘으로 결과값을 계산할 수 있었다.
- 시간복잡도 : O(n * sqrt(n))

problem 37 : **로또의 최고 순위와 최저 순위**

- 문제 해설 : 처음 최고 순위와 최저 순위를 6, 6으로 정해준다. lottos의 값이 0이라면 최고 순위를 -1 해준다. 0이 아닐 땐, win_nums을 돌면서 일치하는 값인지 체크한다. 일치하는 값이라면 최고 순위, 최저 순위를 둘다 -1 해준다.
- 시간복잡도 : O(36)

problem 38 : 음양 더하기 

- 문제해설 : absolution 값을 전부 더하는데 signs이 false면 -를 붙여줘서 더하는 문제입니다.
- 시간복잡도 : O(N)

problem 39 : 신규 아이디 추천 

- 문제해설 : 각 단계별로 전부 구현해서 풀었습니다.
- 시간복잡도 : O(N)

problem 40 : 내적 

- 문제해설 : 말그대로 내적을 구현했습니다.
- 시간복잡도 : O(N)