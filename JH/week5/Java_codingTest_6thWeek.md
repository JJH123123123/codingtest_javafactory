# Java_codingTest_6thWeek

# Java_coding_factory : 6th Week

---

## Solving Programmers level 1 Problems with BaekJoon (6) : 101 - 126

## Problems and Links

| 문제 | 문제 제목 | 문제 유형 | 정보 | 맞힌 사람 | 제출 | 정답 비율 | URL |
| --- | --- | --- | --- | --- | --- | --- | --- |
| problem 101 | 알파벳 개수 | 배열 |  | 31397 | 58124 | 68.306% | [문제](https://www.acmicpc.net/problem/10808) |
| problem 102 | 숫자의 개수 | 배열 |  | 100667 | 202800 | 60.344% | [문제](https://www.acmicpc.net/problem/2577) |
| problem 103 | 방 번호 | 배열 |  | 25508 | 74169 | 44.339% | [문제](https://www.acmicpc.net/problem/1475) |
| problem 104 | 두 수의 합 | 배열 | 다국어 | 17530 | 67014 | 34.385% | [문제](https://www.acmicpc.net/problem/3273) |
| problem 105 | 개수 세기 | 배열 |  | 78732 | 153356 | 61.906% | [문제](https://www.acmicpc.net/problem/10807) |
| problem 106 | 방 배정 | 배열 | 서브태스크 | 10321 | 21531 | 59.780% | [문제](https://www.acmicpc.net/problem/13300) |
| problem 107 | Strfry | 배열 | 다국어 | 5141 | 15529 | 41.141% | [문제](https://www.acmicpc.net/problem/11328) |
| problem 108 | 애너그램 만들기 | 배열 |  | 8457 | 17360 | 59.049% | [문제](https://www.acmicpc.net/problem/1919) |
| problem 109 | 에디터 | 연결 리스트 | 다국어 | 25322 | 133318 | 26.857% | [문제](https://www.acmicpc.net/problem/1406) |
| problem 110 | 키로거 | 연결 리스트 | 다국어 | 13080 | 64550 | 27.823% | [문제](https://www.acmicpc.net/problem/5397) |
| problem 111 | 요세푸스 문제 | 연결 리스트 |  | 43356 | 122863 | 49.058% | [문제](https://www.acmicpc.net/problem/1158) |
| problem 112 | 스택 | 스택 |  | 74759 | 278220 | 37.929% | [문제](https://www.acmicpc.net/problem/10828) |
| problem 113 | 제로 | 스택 | 다국어 | 58504 | 105851 | 68.313% | [문제](https://www.acmicpc.net/problem/10773) |
| problem 114 | 스택 수열 | 스택 |  | 47963 | 174173 | 38.465% | [문제](https://www.acmicpc.net/problem/1874) |
| problem 115 | 탑 | 스택 |  | 19626 | 83523 | 33.196% | [문제](https://www.acmicpc.net/problem/2493) |
| problem 116 | 옥상 정원 꾸미기 | 스택 | 다국어 | 6298 | 22297 | 35.494% | [문제](https://www.acmicpc.net/problem/6198) |
| problem 117 | 오큰수 | 스택 |  | 24308 | 95072 | 34.732% | [문제](https://www.acmicpc.net/problem/17298) |
| problem 118 | 오아시스 재결합 | 스택 | 다국어 | 5799 | 28256 | 27.352% | [문제](https://www.acmicpc.net/problem/3015) |
| problem 119 | 히스토그램에서 가장 큰 직사각형 | 스택 | 다국어 | 10831 | 59359 | 27.366% | [문제](https://www.acmicpc.net/problem/6549) |
| problem 120 | 큐 | 큐 |  | 52253 | 140444 | 49.161% | [문제](https://www.acmicpc.net/problem/10845) |
| problem 121 | 큐 2 | 큐 |  | 29468 | 111605 | 32.763% | [문제](https://www.acmicpc.net/problem/18258) |
| problem 122 | 카드2 | 큐 |  | 55502 | 137180 | 50.929% | [문제](https://www.acmicpc.net/problem/2164) |
| problem 123 | 덱 | 덱 |  | 42756 | 91502 | 56.166% | [문제](https://www.acmicpc.net/problem/10866) |
| problem 124 | 회전하는 큐 | 덱 |  | 24081 | 49010 | 61.792% | [문제](https://www.acmicpc.net/problem/1021) |
| problem 125 | AC | 덱 | 다국어 | 26528 | 163998 | 20.383% | [문제](https://www.acmicpc.net/problem/5430) |
| problem 126 | 최솟값 찾기 | 덱 |  | 8989 | 43657 | 30.892% | [문제](https://www.acmicpc.net/problem/11003) |

## 배운 것 정리

무엇을 배웠고 

어떤 ADT를 가졌는고, 

시간복잡도는 어떻게 되는지
 

## 문제 해설

- 예시
problem 번호:
1. 문제 이해 → 풀이 방향 : 구현, 연산 3개를 구현하는 부분이 까다로울 수도 있을 거 같다.
2. 사용한 자료구조 & 시간복잡도 : O(N)
3. (option 참고 문제 & 참고 링크 등등) : 유사한? 문제 백준 : [https://www.acmicpc.net/problem/1942](https://www.acmicpc.net/problem/1942)
4. 까다로웠던 점 & 논의하고 싶은 부분 : 자바 특성상 임의의 자료형을 정의를 하는 순간 길이가 엄청나게 길어진다. 그게 좀 재밌으면서도 어려웠다.
 

Problem 101: 알파벳 개수 

문제 이해 : 

문제 풀이 : 알파벳 배열을 만들어서 알파벳의 카운트를 저장해주고, 리턴했다. (Counting Sort)

시간 복잡도 : O(N+26)

Problem 102: 숫자의 개수 

문제 풀이 : 알파벳 배열을 만들어서 알파벳의 카운트를 저장해주고, 리턴했다. (Counting Sort)

시간 복잡도 : O(10+10)

Problem 103: 방 번호 

문제 풀이 : 마찬가지로 이 문제 역시 Counting sort를 이용해서 푸는 문제였다. 주어진 숫자를 0이 될 때까지 10으로 나눈 나머지를 카운팅 소트를 해준다. 그렇게 저장한 값들을 이용하여, 6번과 9번은 혼용할 수 있으니 두개를 합쳐서 ret에 할당했다. 이 값이 짝수가 나오면 그냥 2로 나누어주었고, 홀수라면 버려야 하는데, 여기서 문제는 함부로 버리면 안된다. 예를 들어서, 6: 1, 9 : 2인 경우에는 최소 2 세트 이상이 필요하기 때문이다. 그래서 ret가 홀수일 땐 ret = (ret/2) + 1; 해주었고, 9, 6을 제외한 나머지 값에 대해서는 ret과 비교해서 Max값을 찾아주었다. 

시간 복잡도 : O(N)

Problem 104: 두 수의 합 

문제 풀이 : 수열의 사이즈 N이 주어지고, 서로 다른 자연수로 구성된 사이즈 N인 수열이 주어진다. 그리고 타깃 자연수 t가 주어진다. $t = a_i + a_j \  (i\not=j, \ \forall 1\leq i,j\leq N)$를 만족하는 튜플의 개수를 구해야 한다. 문제는 N의 사이즈다. $1\leq N \leq 10^5$ 이므로 $O(N^2)$ 알고리즘 돌릴 수 없다. 따라서 이 경우 못해도 $O(N\log(N))$ 알고리즘을 구현해야 한다. 주어진 조건을 다시 살펴보자. “서로 다른”과 “자연수”를 보고 이분탐색(binary search)를 떠올렸다. 일단 정렬을 하는데 $O(N\log(N))$  이후 자연수 하나에 쿼리 하나이므로 $O(Nlog(N))$ 이다. 따라서 예상 최악의 시간복잡도는 $O(2N\log(N))$라고 생각했고, 무난히 통과할 수 있었다. 

— 물론, Two pointer를 이용해서 $O(N)$ 안에 문제를 해결할 수도 있다. 아래는  c++ code다.

```cpp
// c++ 
#include <alogrithm>
int solution(vector<int> nums, int target){
	sort(nums.begin(), nums.end());
	int i = 0; 
	int j = nums.size()-1;
	int ret = 0;
	while(i<j){
		int tmp = nums[i] + nums[j];
		if(tmp == target){
			 ret++;
			 i++;
			 j--;
		}
		else if(tmp < target){
			i++;
		}else{
			j--;
	}
	return ret;
}
```

Problem 105: 개수 세기 

문제 풀이 : 이 문제도 카운팅 소트를 이용해서 문제를 해결하면 된다. 카운팅 소트를 쓰는 경우는 이 문제처럼 최댓값의 제한이 작거나, 나오는 숫자의 가짓수가 작을 때 카운팅소트를 이용하면 된다. 

시간 복잡도 : O(N)

```java
// Counting Sort Print
static int Solution(int[] nums){
	int N = nums.length;
	int[] cnts = int[N+1];
	for(int i = 0;i<N;i++){
		cnts[nums[i]]++;
	}
	
	StringBuilder sb = new StringBuilder();
	for(int i = 0;i<=N;i++){
		while(cnts[i]-->0){
			sb.append(i + " ");
		}
	}
	System.out.println(sb);
}
```

Problem 106: 방 배정 

문제 풀이 : 앞서 언급한 방 번호의 문제를 좀 더 일반적으로 확장한 문제다. 방 배정의 조건은 정리해보면 세개다. 

- 같은 학년끼리 배정
- 같은 성별끼리 배정
- 한방에 최대 K명.

전체 학년을 배열로 선언한 다음에 각 학년 별로 남,녀의 수를 세야 하므로 int[][] students = new int[6][2]; 로 선언해서 저장해준 뒤에 K로 나눈 몫과 나머지를 계산하여 방의 개수를 계산할 수 있었다. 

시간 복잡도 : O(N + 12)

Problem 107: Strfry 

문제 풀이 : 역시 계수 정렬(카운팅 소트)로 풀었습니다. 문제는 문자열 a와 b가 주어집니다. 주어진 알파벳 a를 카운팅 소트한 배열을 A라고 한다면, b를 카운팅 소트하면서는 더하기가 아니라 빼기를 해야 합니다. 만약에 음수가 나오는 경우에는 false를 리턴하고 “Impossible”을 출력, 그러한 경우가 존재하지 않는 경우는 true를 리턴해서 “Possible”를 출력해줍니다. 

시간 복잡도 : O(N * 26 * 2) 

Problem 108: 애너그램 만들기 

문제 풀이 : 애너그램 만들기는 위의 Strfry이 케이스 1의 구조에서 얼마나 차이가 생기는지를 Math.abs를 이용해서 다 더해서 리턴하면 된다. 

시간 복잡도 : O(|A| + |B| + 26) - 주어진 문자열 A, B

Problem 109: 에디터 

문제 풀이 : DLL(Doubly LinkedList)를 이용해서 현재 커서 왼쪽에 있는 값을 지우거나, 추가하거나, 커서를 왼쪽으로 이동하거나, 오른쪽으로 이동하는 연산을 구현해서 풀었습니다.

자바의 경우 STL LinkedList의 remove가 최악의 경우 O(N)이므로 TLE가 납니다. 

시간 복잡도 : O(N)

Problem 110: 키로거 

문제 풀이 : 에디터와 마찬가지의 문제다. 이 문제를 풀 때는 deque를 이용해서 풀었다. 

[     왼 쪽       ] 현재 커서 [      오른쪽        ] 

< 가 나올 땐 오른쪽 deque을 poll_first를 해서 왼쪽의 deque에 addLast를 해줬습니다. 

> 가 나올 땐 오른쪽 deque을 poll_Last를 해서 오른쪽의 deque에 addFirst를 해줬습니다. 

- 가 나올 땐 왼쪽의 deque을 poll_last를 했습니다.

이후 Left deque부터 right deque까지 결과를 문자열로 바꿔 리턴했습니다. 

시간 복잡도 : O(N)

Problem 111: 요세푸스 문제 

문제 풀이 : 이 문제는 N, K의 값이 작기 때문에 시간복잡도 O(NK)도 충분히 돌아간다. 원형큐를 구현해서 풀었다. 

시간 복잡도 : O(NK)

Problem 112: 스택 

문제 풀이 : 스택을 DLL를 이용해서 구현해서 풀었다. 

시간 복잡도 : O(N)

Problem 113: 제로 

문제 풀이 : 자연수 N이 주어진다. N만큼 인풋이 들어오는데 인풋의 숫자가 0이 아니면 스택에 push를 하고, 0이면 스택을 pop한다. 인풋이 끝나면 스택의 사이즈를 리턴한다. 

시간 복잡도 : O(N)

Problem 114: 스택 수열 

문제 풀이 : 입력은 첫 줄에 N, 이후 N개의 줄에 1부터 N 사이의 정수가 하나씩 주어집니다

- 1부터 N까지의 수를 스택에 오름차순으로 push하고 pop하여 주어진 수열을 만들 수 있는지 확인합니다.
- 주어진 수열을 만들 수 있으면 push와 pop 연산을 순서대로 출력합니다.
- 만들 수 없으면 "NO"를 출력합니다.

시간 복잡도 : O(N)

Problem 115: 탑 

문제 풀이 : 

시간 복잡도 : 

Problem 116: 옥상 정원 꾸미기 

문제 풀이 : 

시간 복잡도 : 

Problem 117: 오큰수 

문제 풀이 : 

시간 복잡도 : 

Problem 118: 오아시스 재결합 

문제 풀이 : 

시간 복잡도 : 

Problem 119: 히스토그램에서 가장 큰 직사각형 

문제 풀이 : 

시간 복잡도 : 

Problem 120: 큐 

문제 풀이 : 

시간 복잡도 : 

Problem 121: 큐 2

문제 풀이 : 

시간 복잡도 : 

Problem 122: 카드 2 

문제 풀이 : 

시간 복잡도 : 

Problem 123: 덱 

문제 풀이 : 

시간 복잡도 : 

Problem 124: 회전하는 큐 

문제 풀이 : 

시간 복잡도 : 

Problem 125: AC 

문제 풀이 : 

시간 복잡도 : 

Problem 126: 최솟값 찾기 

문제 풀이 : 

시간 복잡도 :